<?xml version="1.0" encoding="UTF-8"?>
<quiz>
<!-- question: 0  -->
  <question type="category">
    <category>
        <text>EXPORT_UOC_PROTOTYPES</text>

    </category>
  </question>

<!-- question: 14933  -->
  <question type="coderunner">
    <name>
      <text>UOC_PROTOTYPE_python3_cosc121</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p>Prototype for a COSC121 Python3 question that is checked by pylint before being executed. Other style checks are also implemented.</p><p>It can take the following template parameters:</p>
<ul>
<li>isfunction: unless this isexplicitly set to false, a dummy module docstring will be inserted at the start of the program <b>unless there is one there&nbsp;</b><b>already</b>. Thus, if your question is of the "write a program" variety, you <i>should</i>&nbsp;set this to false. Otherwise omit it.</li><li><span style="font-size: 14px;">pylintoptions: this should be a JSON list of strings.&nbsp;</span><span style="font-size: 14px;">For example, the Template parameters string in the question authoring form might be set to</span><p>{"isfunction": false, "pylintoptions":["--max-statements=20","--max-args=3"]}&nbsp;<span style="font-size: 14px;">to suppress the insertion of a dummy module docstring at the start and to set the maximum number of statements and arguments for each function to 20 and 3 respectively.</span></p></li><li><p>usestandardinput: if present and true, the standard builtin Python <i>input</i> function will be used. Otherwise, it will be replaced with a version that echoes the prompt to standard output to mimic the behaviour observed when standard input comes from the keyboard</p></li><li><p>proscribedfunctions: this is a list of functions (sum, product, etc) that <b>must not</b> appear in the student's program.</p></li><li><p>proscribedconstructs: this is a list of Python constructs (if, while, def, etc) that <b>must not</b> appear in the student's program.</p></li><li><p>requiredconstructs:&nbsp;<span style="font-size: 14px;">this is a list of Python constructs (if, while, def, etc) that</span><b style="font-size: 14px;"> must </b><span style="font-size: 14px;">appear in the student's program.</span></p></li><li><p><span style="font-size: 14px;">imports: this is a list of Python modules to be imported, each with a line of the form <i>import module</i>.</span></p></li><li><p><span style="font-size: 14px;">allowglobals: set this to true to allow global variables (i.e. to allow lowercase globals, not just "constants")</span></p></li><li><p><span style="font-size: 14px;">maxnumconstants: the maximum number of constants (i.e. uppercase globals) allowed. An integer, defaulting to 4.</span></p></li><li><p><span style="font-size: 14px;">norun: if set to true, the normal execution of the student's code will not take place. Any test code provided will however still be run.</span></p></li><li><p><span style="font-size: 14px;">notest: if present and set to true, the test code will not be inserted into the code to be executed. Its role is then just as documentation for the student (as it still appears in the result table).</span></p></li><li><p><span style="font-size: 14px;">stripmain: if set to true, the program is expected to contain a global invocation of the main function, which is a line starting "main()". That line is deleted from the program. If the line is not present a "Missing call to main" exception is raised.</span></p></li><li><p><span style="font-size: 14px;">stripmainifpresent:
 if set to true and the program contains a global invocation of a main function, which is a line starting "main()", that line is 
deleted from the program. Otherwise nothing happens (cf stripmain).</span></p></li><li><p><span style="font-size: 14px;">runextra: if set (to any value) the Extra Template Data is added to the program as test code <i>before</i> the usual testcode.</span></p></li><li><p><span style="font-size: 14px;">warnifpassiveoutput: if set to true, warn the student that the code seems to produce output even without any CodeRunner tests being executed. This is probably the result of the student pasting test code as well as requested function(s) into their answer.</span></p></li><li><p><span style="font-size: 14px;">suppresspassiveoutput: if set to true, any output generated by the student code even without any CodeRunner tests being run is ignored. This can be used, for example, to ignore output from any test code the student has included <i>and/or</i>&nbsp;to ignore the main output from a "write a program question". Only the output generated by CodeRunner tests will be displayed and marked.</span></p></li>
</ul>
<p>Also, if a file named '_prefix.py' appears in the working directory (i.e. has been attached to the question), the
 code in that file is inserted into the executable program after any 
imports and other template-generated code but before the student answer.<br></p>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>1.0000000</defaultgrade>
    <penalty>0.0000000</penalty>
    <hidden>0</hidden>
    <coderunnertype>python3_cosc121</coderunnertype>
    <prototypetype>2</prototypetype>
    <allornothing>1</allornothing>
    <penaltyregime>0,10,20...</penaltyregime>
    <precheck>1</precheck>
    <showsource>0</showsource>
    <answerboxlines>60</answerboxlines>
    <answerboxcolumns>100</answerboxcolumns>
    <answerpreload></answerpreload>
    <useace>1</useace>
    <resultcolumns></resultcolumns>
    <template><![CDATA[__student_answer__ = """{{ STUDENT_ANSWER | e('py') }}""" + '\n'

import subprocess
import os
import sys
import re
import ast
import io
import traceback


{% if QUESTION.parameters.usestandardinput is not defined or not (QUESTION.parameters.usestandardinput) %}
__saved_input__ = input
def input(prompt=''):
    """ Replace the standard input prompt with a cleverer one. """
    try:
        s = __saved_input__(prompt)
    except EOFError:
        print("'input' function called when no input data available.", file=sys.stderr)
        sys.exit(1)
    print(s)
    return s

{% endif %}


__oldopen = open
def open(file, mode='r', buffering=-1, 
         encoding='utf-8', errors=None, 
         newline=None, closefd=True, opener=None):
    return __oldopen(file, mode, buffering, encoding, errors, newline, closefd, opener)


prelude = ''
{% for imp in QUESTION.parameters.imports %}
prelude += """import {{imp}}\n"""
{% endfor %}


try:
    with open('_prefix.py') as prefix:
        prelude += '\n' + prefix.read()
except FileNotFoundError:
    pass


def pylint_is_happy(s):
{% if QUESTION.parameters.isfunction or not (QUESTION.parameters.isfunction is defined) %}
    if len(s.strip()) == 0 or s.strip()[0] not in ['"', "'"]:
        s = "'''Dummy module docstring'''\n" + s  # Add module docstring if nec.
{% endif %}
    try:
        source = open('source.py', 'w')
        source.write(s)
        source.close()
        env = os.environ.copy()
        env['HOME'] = os.getcwd()
        pylint_opts = ['--disable=C0303,C0325,C0330,R0903,R0915,star-args,' +
                      'consider-using-enumerate,simplifiable-if-statement,' +
                      'consider-iterating-dictionary,trailing-newlines',
                      '--enable=C0326',
                      '--good-names=i,j,k,n,s,c,_',
                      '--max-statements=24']
{% if QUESTION.parameters.allowglobals %}
        pylint_opts.append("--const-rgx='[a-zA-Z_][a-zA-Z0-9_]{2,30}$'")
{% endif %}
{% for option in QUESTION.parameters.pylintoptions %}
        pylint_opts.append('{{option}}')
{% endfor %}
        cmd = 'python3 -m pylint ' + ' '.join(pylint_opts) + ' source.py'
        result = subprocess.check_output(cmd, stderr=subprocess.STDOUT, env=env, shell=True)
    except Exception as e:
        result = e.output.decode('utf-8')

    if result.strip():
        print("Sorry, but your code doesn't pass the pylint style checks.", file=sys.stderr)
        print(result)
        return False
    else:
        return True


def find_function_calls(code, func_name):
    """Determine if the given code contains a call to a 'main' function."""
    class MainFinder(ast.NodeVisitor):
        
        def __init__(self, *args, **kwargs):
            self.depth = 0
            self.found = []
            super().__init__(*args, **kwargs)
        
        def visit_FunctionDef(self, node):
            """ Every time we enter a function, we get 'deeper' into the code.
                We want to note how deep a function is when we find its call."""
            self.depth += 1
            self.generic_visit(node)
            self.depth -= 1
        
        def visit_Call(self, node):
            """A function has been called, so check its name 
               against the given one."""
            try:
                name = node.func.id
                if name == func_name:
                    # Line numbers are 1-indexed, so decrement by 1
                    self.found.append((node.lineno - 1, self.depth))
            except AttributeError:
                pass  # either not calling a function (??) or it's not named.
            self.generic_visit(node)
    
    tree = ast.parse(code)
    visitor = MainFinder()
    visitor.visit(tree)
    return visitor.found


def find_illegal_functions(code, illegal_names):
    """Raise an exception if the code contains a call 
       to a function in illegal_names."""
    
    bad_used = set()
    
    class FoulFinder(ast.NodeVisitor):
        
        def visit_Call(self, node):
            """A function has been called, so check its name 
               against the bad ones."""
            try:
                name = node.func.id
                if name in illegal_names:
                    bad_used.add(name)
            except AttributeError:
                pass  # either not calling a function (??) or it's not named.
    
    tree = ast.parse(code)
    visitor = FoulFinder()
    visitor.visit(tree)
    
    if bad_used:
        if len(bad_used) == 1:
            name, = bad_used
            raise Exception("You called the banned "
                            "function '{}'. Tsk tsk!".format(name))
        else:
            names = ', '.join(bad_used)
            raise Exception("You called the following banned functions. Tsk tsk!\n"
                            "    {}".format(names))


def find_too_long_funcs(code, max_length):
    """Return a list of the functions that exceed the given max_length.
       Each list element is a tuple of the function name and the number of statements
       in its body."""

    bad_funcs = []
    
    class MyVisitor(ast.NodeVisitor):

        def visit_FunctionDef(self, node):

            def count_statements(node):
                """Number of statements in the given node and its children"""
                count = 1
                if isinstance(node, ast.Expr) and isinstance(node.value, ast.Str):
                    count = 0
                else:
                    for attr in ['body', 'orelse', 'finalbody']:
                        if hasattr(node, attr):
                            children = node.__dict__[attr]
                            count += sum(count_statements(child) for child in children)
                return count
            
            num_statements = count_statements(node) - 1 # Disregard def itself
            if num_statements > max_length:
                bad_funcs.append((node.name, num_statements))

        def visit_AsyncFunctionDef(self, node):
            self.visit_FunctionDef(node)


    tree = ast.parse(code)
    visitor = MyVisitor()
    visitor.visit(tree)
    return bad_funcs
    
        

def __contains__(code, construct):
    '''True iff the given construct is used in code.'''
    constructs_seen = set()
    class ConstructFinder(ast.NodeVisitor):
        def visit_Assert(self, node):
            constructs_seen.add('assert')
            self.generic_visit(node)
        def visit_Raise(self, node):
            constructs_seen.add('raise')
            self.generic_visit(node)
        def visit_Lambda(self, node):
            constructs_seen.add('lambda')
            self.generic_visit(node)
        def visit_Import(self, node):
            constructs_seen.add('import')
            self.generic_visit(node)
        def visit_ImportFrom(self, node):
            constructs_seen.add('import')
            self.generic_visit(node)
        def visit_For(self, node):
            constructs_seen.add('for')
            self.generic_visit(node)
        def visit_While(self, node):
            constructs_seen.add('while')
            self.generic_visit(node)
        def visit_If(self, node):
            constructs_seen.add('if')
            self.generic_visit(node)
        def visit_Break(self, node):
            constructs_seen.add('break')
            self.generic_visit(node)
        def visit_Continue(self, node):
            constructs_seen.add('continue')
            self.generic_visit(node)
        def visit_Try(self, node):
            constructs_seen.add('try')
            self.generic_visit(node)
        def visit_TryExcept(self, node):
            constructs_seen.add('try')
            constructs_seen.add('except')
            self.generic_visit(node)
        def visit_TryFinally(self, node):
            constructs_seen.add('try')
            constructs_seen.add('finally')
            self.generic_visit(node)
        def visit_ExceptHandler(self, node):
            constructs_seen.add('except')
            self.generic_visit(node)
        def visit_With(self, node):
            constructs_seen.add('with')
            self.generic_visit(node)
        def visit_Yield(self, node):
            constructs_seen.add('yield')
            self.generic_visit(node)
        def visit_YieldFrom(self, node):
            constructs_seen.add('yield')
            self.generic_visit(node)
    
    tree = ast.parse(code)
    visitor = ConstructFinder()
    visitor.visit(tree)
    return construct in constructs_seen


class CodeTrap(object):
    """ A safe little container to hold the student's code and grab
        its output, while also reformatting exceptions to be nicer
    """

    def __init__(self, student_code, pre_code=None, post_code=None):
        self.student_code = student_code
        self.pre_code = pre_code if pre_code else ''
        self.post_code = post_code if post_code else ''
        self.run_code = self.pre_code + '\n' + self.student_code + '\n' + self.post_code
        self.offset_out = 0
        self.offset_err = 0

    def __enter__(self):
        self.old_stdout = sys.stdout
        self.old_stderr = sys.stderr
        sys.stdout = io.StringIO()
        sys.stderr = io.StringIO()
        return self

    def __exit__(self, *args):
        sys.stdout = self.old_stdout
        sys.stderr = self.old_stderr

    def exec(self):
        """ Run the code. Report any errors to stderr,
            made pretty and correct for the student code.
        """
        try:
            exec(self.run_code, globals())
        except Exception as e:
            etype, value, tb = sys.exc_info()
            tb_tuples = traceback.extract_tb(tb)
            new_tb = []
            for filename, linenumber, scope, text in tb_tuples:
                if filename == "<string>":
                        new_tb.append((
                            "student_code.py",
                            linenumber - len(self.pre_code.split('\n')),
                            scope,
                            self.run_code.split('\n')[linenumber - 1].strip()
                        ))
            print("Traceback (most recent call last):", file=sys.stderr)
            print(''.join(traceback.format_list(new_tb)), end='', file=sys.stderr)
            print(traceback.format_exception_only(etype, value)[-1], end='', file=sys.stderr)
            return True
        except SystemExit as e:
            return True
        except KeyboardInterrupt as e:
            print("KeyboardInterrupt", file=sys.stderr)
        except GeneratorExit as e:
            print("GeneratorExit", file=sys.stderr)

    def read(self):
        """ Grab the additions to stdout and stderr since last read.
        """
        sys.stdout.seek(self.offset_out)
        output = sys.stdout.read()
        self.offset_out = len(output)
        sys.stderr.seek(self.offset_err)
        error = sys.stderr.read()
        self.offset_err = len(error)
        return output, error
    

def produces_passive_output(student_code):
    """ Check whether the given code produces output without any prompting.
    This is essentially a "dry run" of the code.
    """
    with CodeTrap(student_code, prelude) as t:
        t.exec()
        captured_output, captured_error = t.read()
    return captured_output.strip() != '' or captured_error.strip() != ''
    
    

def local_checks_ok(code):
    """Perform various local checks as specified by the current set of 
       template parameters. Note that if either stripmain of stripmainifpresent
       is defined the global __student_answer__ is updated (shock, horror).
    """
    global __student_answer__
    errors = []
{% if QUESTION.parameters.maxfunctionlength is defined %}
    allowed = int("{{ QUESTION.parameters.maxfunctionlength }}")
{% else %}
    allowed = 20
{% endif %}
    illegal_functions = []
{% for func in QUESTION.parameters.proscribedfunctions %}
    illegal_functions.append("{{func}}")
{% endfor %}
    find_illegal_functions(code, illegal_functions)
    bad_funcs = find_too_long_funcs(code, allowed)
    for func, count in bad_funcs:
        errors.append("Function '{}' is too long ({}/{})".format(func, count, allowed))
{% for reqd in QUESTION.parameters.requiredconstructs %}
    if not __contains__(code, '{{reqd}}'):
        errors.append("Your program must include at least one " + '{{reqd}}' + " statement.")
{% endfor %}
{% for notallowed in QUESTION.parameters.proscribedconstructs %}
    if __contains__(code, '{{notallowed}}'):
        errors.append("Your program must not include any " + '{{notallowed}}' + " statements.")
{% endfor %}
    num_constants = len([line for line in code.split('\n') if re.match('[A-Z_][A-Z_0-9]* *=', line)])
{% if QUESTION.parameters.maxnumconstants is defined %}
    max_allowed = {{ QUESTION.parameters.maxnumconstants }}
{% else %}
    max_allowed = 4
{% endif %}
    if num_constants > max_allowed:
        errors.append("You may not use more than " + str(max_allowed) + " constants.")
{% if QUESTION.parameters.warnifpassiveoutput 
   or QUESTION.parameters.isfunction %}
    if produces_passive_output(code):
        errors.append("Your code was not expected to generate any output " +
            "when executed stand-alone.\nDid you accidentally include " +
            "your test code?")
{% endif %}
{% if QUESTION.parameters.stripmain or QUESTION.parameters.stripmainifpresent %}
    main_calls = find_function_calls(code, 'main')
{% endif %}        
{% if QUESTION.parameters.stripmain %}
    if main_calls == []:
        errors.append("No call to main() found")
{% endif %}
{% if QUESTION.parameters.stripmain or QUESTION.parameters.stripmainifpresent %}
    student_lines = __student_answer__.split('\n')
    for (line, depth) in main_calls:
        if depth == 0:
            student_lines[line] = student_lines[line].replace("main", 
                                                               "pass  # main")
            student_lines[line] += "  # Don't call main here!"
        else:
            template = "{}  # We've let you call main here."
            student_lines[line] = template.format(student_lines[line])
    __student_answer__ = '\n'.join(student_lines) + '\n'
{% endif %}

    for error in errors:
        print(error, file=sys.stderr)
    return len(errors) == 0
    

def run_test(pre_code, student_answer, post_code, skip_student_output=False):
    """ Run the student code, with precode and post_code adjoined.
        If skip_student_output is true, we skip any output produced
        by the student's code without prompting.
    """
    io_sep = "#$<cr@931659>$#"
    io_print = "\nprint('" + io_sep + "')\n"
    prefix = pre_code + io_print
    if skip_student_output:
        postfix = '\nsys.stdin.seek(0)'
    else:
        postfix = ''
    postfix += io_print + post_code
    with CodeTrap(student_answer, prefix, postfix) as t:
        t.exec()
        captured_output, captured_error = t.read()
    if captured_error.strip() != '':
        print(captured_output.replace(io_sep + '\n', ''), end='')
        print(captured_error, file=sys.stderr, end='')
        exit(1)
    pre, middle, post = captured_output.split(io_sep + '\n')
    if skip_student_output:
        middle = ''
    print(pre + middle + post)


if (pylint_is_happy(prelude + __student_answer__) and local_checks_ok(__student_answer__)):
    __SEPARATOR__ = "#<ab@17943918#@>#"
{% if not IS_PRECHECK or QUESTION.precheck != 1 %}
{% for TEST in TESTCASES %}
    student_code_to_run = ''
    post_code_to_run = ''
    cut_passive = False
{% if not QUESTION.parameters.norun %}
    student_code_to_run = __student_answer__
{% endif %}
{% if QUESTION.parameters.runextra %}
    post_code_to_run += '\n' + """{{ TEST.extra | e('py') }}""" + '\n'
{% endif %}
{% if not QUESTION.parameters.notest %}
    post_code_to_run += '\n' + """{{ TEST.testcode | e('py') }}""" + '\n'
{% endif %}
{% if QUESTION.parameters.suppresspassiveoutput %}
    cut_passive = True
{% endif %}
    run_test(prelude, student_code_to_run, post_code_to_run, skip_student_output=cut_passive)
{% if not loop.last %}
    print(__SEPARATOR__)
{% endif %}
{% endfor %}
{% else %}
    pass
{% endif %}]]></template>
    <iscombinatortemplate>1</iscombinatortemplate>
    <answer></answer>
    <validateonsave>0</validateonsave>
    <testsplitterre><![CDATA[|#<ab@17943918#@>#\n|ms]]></testsplitterre>
    <language>python3</language>
    <acelang></acelang>
    <sandbox></sandbox>
    <grader>EqualityGrader</grader>
    <cputimelimitsecs></cputimelimitsecs>
    <memlimitmb></memlimitmb>
    <sandboxparams></sandboxparams>
    <templateparams></templateparams>
    <testcases>
    </testcases>
  </question>

<!-- question: 14934  -->
  <question type="coderunner">
    <name>
      <text>UOC_PROTOTYPE_python3_pylint</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p>Prototype for a Python3 question that is checked by pylint before being executed. It can take two template parameters:</p>
<ul>
<li>isfunction: if set and true a dummy module docstring will be inserted at the start of the program. This is useful in "write a function" questions.</li>
<li>pylintoptions: this should be a JSON list of strings.</li>
</ul>
<p>For example, the Template parameters string in the question authoring form might be set to</p>
<p>{"isfunction": true, "pylintoptions":["--max-statements=20","--max-args=3"]}</p>
<p>to generate a module docstring at the start and to set the maximum number of statements and arguments for each function to 20 and 3 respectively.</p>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>1.0000000</defaultgrade>
    <penalty>0.0000000</penalty>
    <hidden>0</hidden>
    <coderunnertype>python3_pylint</coderunnertype>
    <prototypetype>2</prototypetype>
    <allornothing>1</allornothing>
    <penaltyregime>0,0,0,0,0,0,10,20,...</penaltyregime>
    <precheck>0</precheck>
    <showsource>0</showsource>
    <answerboxlines>60</answerboxlines>
    <answerboxcolumns>100</answerboxcolumns>
    <answerpreload></answerpreload>
    <useace>1</useace>
    <resultcolumns></resultcolumns>
    <template></template>
    <iscombinatortemplate>0</iscombinatortemplate>
    <answer></answer>
    <validateonsave>0</validateonsave>
    <testsplitterre><![CDATA[|#<ab@17943918#@>#|ms]]></testsplitterre>
    <language>python3</language>
    <acelang></acelang>
    <sandbox></sandbox>
    <grader>EqualityGrader</grader>
    <cputimelimitsecs>30</cputimelimitsecs>
    <memlimitmb>1024</memlimitmb>
    <sandboxparams></sandboxparams>
    <templateparams></templateparams>
    <testcases>
    </testcases>
  </question>

</quiz>